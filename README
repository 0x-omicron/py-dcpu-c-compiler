This is a simple C compiler. It compies to the DCPU-16.

It is written in Python and is meant to be small. Currently it is ~500 LOC
excluding parsing.

It currently supports many (but not nearly all) features of C:
   - Recursion
   - Pointers
   - Flow control (if/while/for)
   - Heap allocated strings
   - Global variables

Notably, the following features are lacking:
   - Error handling: python crashes on invalid programs.
   - Any type checking what-so-ever.
   - Structs.
   - Function pointers.
   - Stack arrays.

Function calls are also very expensive, resulting in >5 instructions.

Parsing is done through the pycparser (http://code.google.com/p/pycparser/).

Run it as

python compiler.py [-n] [-d] [-o outputfile] inputfile

where
   -n disables optimizations
   -d print debugging information about the compilation
   -o outfile writes the output to the given file 

The output is the instructions, as base-16 encoded words separated by spaces.

When running any file, the return from main is placed in register I.


EXAMPLES


Here is a sample input file.

int main() {
  int a = 2;
  int b = 3;
  return a+b;
}

After running the output through a disassembler, here is what we get:

0000: JSR 0x04                       ; Jump to the main method
0002: SET PC, 0x02 		     ; Loop here forever
0004: SUB SP, 0x03		     ; Make space for our variables
0006: SET J, SP			     ; Copy the stack pointer over to J
0007: SET [J], 0x02		     ; Push 2 on to the stack
0008: SET [0x01 + J], 0x03	     ; Push 3 on to the stack
000a: SET [0x02 + J], [J]	     ; Move 2 to the result location
000c: ADD [0x02 + J], [0x01 + J]     ; Do the addition with 3
000f: ADD SP, 0x03    	             ; Start tearing down the satck
0010: SET I, [0x02 + J]		     ; Copy the return value
0012: SET PC, POP    		     ; Return to the top
0013: ADD SP, 0x03		     ; Inserted in case we got here
0014: SET PC, POP		     ; Inserted in case we got here


A slightly more sophisticated example follows:


int fib(int a) {
  if (a <= 1) {
    return 1;
  }
  return fib(a-1)+fib(a-2);
}

int main() {
  return fib(10);
}


With the output again:


0000: JSR 0x31			     ; Call to main
0002: SET PC, 0x02
				     ; Start of fib
0004: SUB SP, 0x03		     ; Set up stack space for fib
0006: SET J, SP
0007: IFN [0x04 + J], 0x01	     ; Two instructions to test
0009: IFG 0x01, [0x04 + J]	     ;  if a <= 1
000b: SET PC, 0x0f    		     ; If true, goto 0x0f
000d: SET PC, 0x12		     ; If false, goto 0x12
     	      			     ; The if-false case
000f: ADD SP, 0x03		     ; Clean up the stack
0010: SET I, 0x01		     ; Set the return value
0011: SET PC, POP		     ; And do the return
     	      			     ; The if-true case
0012: SET [J], [0x04 + J]	     ; Copy the argument
0014: SUB [J], 0x01
0015: SET PUSH, [J]		     ; Push the argument		       
0016: JSR 0x04			     ; Make recursive call #1
0018: ADD SP, 0x01		     ; Remove argument
001a: SET J, SP
001b: SET [0x01 + J], I		     ; Save result
001d: SET [J], [0x04 + J]
001f: SUB [J], 0x02
0020: SET PUSH, [J]		     ; Push argument again
0021: JSR 0x04			     ; Make recursive call #2
0023: ADD SP, 0x01
0025: SET J, SP
0026: SET [0x02 + J], I		     ; Save result
0028: SET [J], [0x01 + J]	     ; Copy result
002a: ADD [J], [0x02 + J]	     ; Sum together
002c: ADD SP, 0x03     		     ; Clean up
002d: SET I, [J]		     ; Save result
002e: SET PC, POP		     ; Return
002f: ADD SP, 0x03
0030: SET PC, POP
				     ; Start of main
0031: SUB SP, 0x01		     ; Need stack space
0033: SET J, SP
0034: SET PUSH, 0x0a
0035: JSR 0x04			     ; Call to fib
0037: ADD SP, 0x01
0039: SET J, SP
003a: SET [J], I		     ; Retrieve the return value
003b: ADD SP, 0x01
003c: SET I, [J]		     ; Place the return value
003d: SET PC, POP		     ; Return
003e: ADD SP, 0x01
003f: SET PC, POP



Finally, the Miller-Rabin test for primality is included as example/3.c


int isPrime1(int n) {
  if (n == 2) return 1;
  if (n%2 == 0) return 0;
  int t = 3;
  while (t*t <= n) {
    if ((n%t) == 0) {
      return 0;
    } else {
      t += 2;
    }
  }
  return 1;
}

int modpow(int a, int d, int n) {
  int r = 1;
  int i;
  for (i = 0; i < d; i++) {
    r = (r*a)%n;
  }
  return r;
}

int isPrime2(int n) {
  int nc = n-1;
  int s = 0;
  while ((nc&1) == 0) {
    s += 1;
    nc >>= 1;
  }
  int d = n>>s;
  int a = 2;
  while (a <= 3) {
    if (isPrime1(a)) {
      if (modpow(a,d,n) != 1 & modpow(a,d,n) != n-1) {
	int r = 0;
	int worked = 0;
	while ((r <= s-1) & (r <= s)) {
	  if (modpow(a, (2<<r)*d, n) == n-1) {
	    worked = 1;
	  }
	  r += 1;
	}
	if (worked == 0) {
	  return 0;
	}
      }
    }
    a++;
  }
  return 1;
}


int main() {
  return isPrime2(1003);
}
